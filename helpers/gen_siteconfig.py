#!/bin/python3
"""
Generates the enum type for SiteConfig preference
models.

This does require a valid JSON response from an
XNAT host in order to generate the expected
output.

An example of how to acquire said JSON and parse
into `siteconfig.rs`:
```bash
$ wget -qO - --user=<USER> --password=<PASS> https://your.xnat.host/xapi/siteConfig | helpers/gen_siteconfig.py
```
"""

import io, json, os, sys


def determine_conversion(kind: str) -> tuple[str, str]:
        if "Vec" in kind:
            sub_kind = kind.replace("Vec<", "").replace(">", "")
            sk_sub_kind, conversion = determine_conversion(sub_kind)
            conversion = conversion.replace("value", "vi")
            return "Array", f"value.iter().map(|vi| Value::{sk_sub_kind}({conversion})).collect::<Vec<Value>>()"
        elif kind == "u64":
            return "Number", "value.to_owned().into()"
        else:
            return kind.capitalize(), "value.to_owned()"


def determine_match_arm(kind: str) -> str:
        if "Vec" in kind:
            sub_kind = kind.replace("Vec<", "").replace(">", "") 
            match_arm  =  "Value::Array(v) => v.iter().filter_map(|vi| match vi {\n"
            match_arm += f"                {determine_match_arm(sub_kind)},\n"
            match_arm +=  "                _ => None,\n"
            match_arm += f"            }}).collect::<Vec<{sub_kind}>>().into()"
        elif kind == "u64":
            match_arm = "Value::Number(v) => v.to_owned().as_u64()"
        else:
            match_arm = f"Value::{kind.capitalize()}(v) => v.to_owned().into()"

        return  match_arm


def determine_type(value: object) -> str:
    match str(type(value)):
        case "<class 'str'>":
            return "String"
        case "<class 'bool'>":
            return "bool"
        case "<class 'int'>":
            return "u64"
        case "<class 'list'>" if isinstance(value, list) and len(value):
            return f"Vec<{determine_type(value[0])}>"
        # Default to string if can't determine
        # type of list items.
        case "<class 'list'>":
            return "Vec<String>"
        # Give up entirely if we can't determine
        # type of `value`.
        case w:
            return w


def snake(key: str) -> str:
    return (""
        .join(("_" + ch if ch.isupper() else ch for ch in key))
        .lower()
        .replace("-", ""))


def write_line(fd: io.TextIOWrapper, data: str | None = None, *args) -> None:
    data = data or ""
    if args:
        data = data.format(*args)
    fd.write(data + os.linesep)


def do_writes(fd: io.TextIOWrapper, data: dict[tuple[str, str], str]) -> None:
    # Generate top-level doc string for this
    # submodule.
    write_line(fd, "//! Generated via `helpers/gen_siteconfig.py`")
    write_line(fd, "//! Do not edit this file directly.")
    write_line(fd, "//! ")
    write_line(fd, "//! Defines models and model units available to a")
    write_line(fd, "//! user for manipulating `siteConfig` values.")
    write_line(fd)

    # Include necessary assets.
    write_line(fd, "use std::collections::HashMap;")
    write_line(fd)
    write_line(fd, "use serde::{Deserialize, Serialize};")
    write_line(fd, "use serde_json::Value;")
    write_line(fd)

    # Define enum units for `SiteConfig`
    # preferences.
    write_line(fd, "/// Units available within a `SiteConfig` model.")
    write_line(fd, "/// These values then do also define the")
    write_line(fd, "/// site-wide configuration values.")
    write_line(fd, "#[derive(Debug, Deserialize, Serialize)]")
    write_line(fd, "pub enum SiteConfigPreference {")
    for key in sorted(data.keys()):
        cameled, shouting_cameled = key
        kind = data[key]

        write_line(fd, f"    #[serde(rename = \"{cameled}\")]")
        write_line(fd, f"    {shouting_cameled}({kind}),")
    write_line(fd, "}")
    write_line(fd)

    # Define the mane `SiteConfig` struct.
    write_line(fd, "/// siteConfig, or site-wide configuration of,")
    write_line(fd, "/// some XNAT host. Values are digested into a")
    write_line(fd, "/// `metadata` field where then options can be")
    write_line(fd, "/// accessed through subsequent property traits.")
    write_line(fd, "#[derive(Debug, Deserialize, Serialize)]")
    write_line(fd, "pub struct SiteConfig {")
    write_line(fd, "    #[serde(flatten)]")
    write_line(fd, "    metadata: HashMap<String, Value>,")
    write_line(fd, "}")
    write_line(fd)

    # Define relevant traits to break up the
    # necessary getters and setters of
    # specific properties.
    for key in sorted(data.keys()):
        cameled, shouting_cameled = key
        snaked = snake(cameled)
        kind = data[key]

        write_line(fd, f"pub trait {shouting_cameled} {{")
        write_line(fd, f"    /// Getter for the `{cameled}` property.")
        write_line(fd, f"    fn get_{snaked}(&self) -> Option<SiteConfigPreference>;")
        write_line(fd, f"    /// Setter for the `{cameled}` property.")
        write_line(fd, f"    fn set_{snaked}(&mut self, value: {kind});")
        write_line(fd, "}")
        write_line(fd)

        match_arm = determine_match_arm(kind)
        write_line(fd, f"impl {shouting_cameled} for SiteConfig {{")
        write_line(fd, f"    fn get_{snaked}(&self) -> Option<SiteConfigPreference> {{")
        write_line(fd, f"        SiteConfigPreference::{shouting_cameled}(match self.metadata.get(\"{cameled}\")? {{")
        write_line(fd, f"            {match_arm},")
        write_line(fd, f"            _ => None,")
        write_line(fd, "        }?).into()")
        write_line(fd, "    }")
        write_line(fd)

        sub_kind, conversion = determine_conversion(kind)
        write_line(fd, f"    fn set_{snaked}(&mut self, value: {kind}) {{")
        write_line(fd, f"        let key = String::from(\"{cameled}\");")
        write_line(fd, f"        let value = Value::{sub_kind}({conversion});")
        write_line(fd, f"        self.metadata.insert(key, value);")
        write_line(fd, "    }")
        write_line(fd, "}")
        write_line(fd)


def main():
    if len(sys.argv) < 2:
        data = json.load(sys.stdin)
    else:
        data = json.loads(sys.argv[1])

    data_formatted = {}
    for key, value in data.items():
        key_cameled          = key
        key_shouting_cameled = ""

        for part in key.replace("_", "-").split("-"):
            key_shouting_cameled += "".join([part[0].upper(), part[1:]])

        key  = (key_cameled, key_shouting_cameled)
        kind = determine_type(value)
        data_formatted[key] = kind

    with open("siteconfig.rs", "w") as fd:
        do_writes(fd, data_formatted)


if __name__ == "__main__":
    exit(main())
