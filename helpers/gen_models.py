#!/bin/python3
"""
Generates the enum type for SiteConfig preference
models.

This does require a valid JSON response from an
XNAT host in order to generate the expected
output.

An example of how to acquire said JSON and parse
into `siteconfig.rs`:
```bash
$ wget -q --user=<USER> --password=<PASS> https://your.xnat.host/xapi/siteConfig
$ helpers/gen_models.py ./siteConfig ./siteconfig.rs
```
"""

import io, json, os, sys


def determine_conversion(kind: str) -> tuple[str, str]:
        if "Vec" in kind:
            sub_kind = kind.replace("Vec<", "").replace(">", "")
            sk_sub_kind, conversion = determine_conversion(sub_kind)
            conversion = conversion.replace("value", "vi")
            return "Array", f"value.iter().map(|vi| Value::{sk_sub_kind}({conversion})).collect::<Vec<Value>>()"
        elif kind == "u64":
            return "Number", "value.to_owned().into()"
        else:
            return kind.capitalize(), "value.to_owned()"


def determine_match_arm(kind: str) -> str:
        if "Vec" in kind:
            sub_kind = kind.replace("Vec<", "").replace(">", "") 
            match_arm  =  "Value::Array(v) => v.iter().filter_map(|vi| match vi {\n"
            match_arm += f"                {determine_match_arm(sub_kind)},\n"
            match_arm +=  "                _ => None,\n"
            match_arm += f"            }}).collect::<Vec<{sub_kind}>>().into()"
        elif kind == "u64":
            match_arm = "Value::Number(v) => v.to_owned().as_u64()"
        else:
            match_arm = f"Value::{kind.capitalize()}(v) => v.to_owned().into()"

        return  match_arm


def determine_type(value: object) -> str:
    match str(type(value)):
        case "<class 'str'>":
            return "String"
        case "<class 'bool'>":
            return "bool"
        case "<class 'int'>":
            return "u64"
        case "<class 'list'>" if isinstance(value, list) and len(value):
            return f"Vec<{determine_type(value[0])}>"
        # Default to string if can't determine
        # type of list items.
        case "<class 'list'>":
            return "Vec<String>"
        # Give up entirely if we can't determine
        # type of `value`.
        case w:
            return w


def shouting_camel(key: str) -> str:
    shouting_cameled = ""
    for part in key.replace("_", "-").split("-"):
        shouting_cameled += "".join([part[0].upper(), part[1:]])
    return shouting_cameled


def snake(key: str) -> str:
    return (""
        .join(("_" + ch if ch.isupper() else ch for ch in key))
        .lower()
        .replace("-", ""))


def write_line(fd: io.TextIOWrapper, data: str | None = None, *args) -> None:
    data = data or ""
    if args:
        data = data.format(*args)
    fd.write(data + os.linesep)


def do_writes(fd: io.TextIOWrapper, data: dict[tuple[str, str], str]) -> None:
    # Generate top-level doc string for this
    # submodule.
    write_line(fd, "//! Generated via `helpers/gen_models.py`")
    write_line(fd, "//! Do not edit this file directly.")
    write_line(fd, "//! ")
    write_line(fd, "//! Defines models and model units available to a")
    write_line(fd, f"//! user for manipulating `{sys.argv[1]}` values.")
    write_line(fd)

    # Include necessary assets.
    write_line(fd, "use serde::{Deserialize, Serialize};")
    write_line(fd)
    write_line(fd, "use oxinat_derive::ModelProperty;")

    # Define a property wrapper around property
    # values.
    name = shouting_camel(sys.argv[1].split("/")[-1].split(".")[0])
    property_name = f"{name}Property"
    write_line(fd, "#[derive(Debug, Deserialize, Serialize)]")
    write_line(fd, f"pub struct {property_name}<T>(T);")
    write_line(fd)

    # Define enum units for `SiteConfig`
    # preferences.
    for key in sorted(data.keys()):
        cameled, shouting_cameled = key
        kind = data[key]

        write_line(fd, "#[derive(Debug, Serialize, ModelProperty)]")
        write_line(fd, f"#[serde(rename = \"{cameled}\")]")
        write_line(fd, f"pub struct {shouting_cameled}({kind});")
        write_line(fd)

    # # Define the mane `SiteConfig` struct.
    write_line(fd, "#[derive(Debug, Deserialize, Serialize)]")
    write_line(fd, f"pub struct {name} {{")

    for key in sorted(data.keys()):
        cameled, shouting_cameled = key
        snaked = snake(cameled)

        write_line(fd, f"    #[serde(rename = \"{cameled}\")]")
        write_line(fd, "     #[serde(skip_serializing_if = \"Option::is_none\")]")
        write_line(fd, f"    pub {snaked}: Option<{property_name}<{shouting_cameled}>>,")
    write_line(fd, "}")
    write_line(fd)


def main():
    exe_name = sys.argv[0]
    if len(sys.argv) < 2:
        print(f"{exe_name}: error: missing argument [iFILE]", file=sys.stderr)
    if len(sys.argv) < 3:
        print(f"{exe_name}: error: missing argument [oFILE]", file=sys.stderr)

    with open(sys.argv[1]) as fd:
        data = json.load(fd)

    # Formats values to expected/needed values.
    data_formatted = {}
    for key, value in data.items():
        key_cameled          = key
        key_shouting_cameled = shouting_camel(key)


        key  = (key_cameled, key_shouting_cameled)
        kind = determine_type(value)
        data_formatted[key] = kind

    with open(sys.argv[2], "w") as fd:
        do_writes(fd, data_formatted)


if __name__ == "__main__":
    exit(main())
